# 统一事件源
## 程序功能
信号处理函数需要尽快地执行，以确保该信号再次发送时能够及时相应。一种典型的解决方案是：

把信号的主要处理逻辑放在程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码

信号处理函数通常使用管道将信号传递给主循环：信号处理函数往管道的写端写入信号值，主循环则使用I/O复用系统调用监听管道的读端文件描述符的可读事件。

如此一来，信号事件就能和其他I/O事件一样被处理，即统一事件源

## 实现过程
在传统ET非阻塞IO复用程序中添加监听管道的读端，并设置信号的捕获函数为向管道的写端写入信号值

注意：**必须使用`sigaction`系统调用进行捕获函数的注册，并设置`sigaction.sa_flags |= SA_RESTART`**。因为使用I/O复用系统调用监听时，如果发生信号，
系统调用会被打断，返回`-1`并设置`errno`为`EINTR`，只有设置重新调用被信号终止的系统调用我们才能正常进行主循环

同时因为上面的原因，`epoll_wait`的返回值为`-1`时必须判断一下`errno`是否是`EINTR`，我就是因为忘记这里会出错，每次发送信号之后`epoll_wait`
都直接报错退出运行（因为使用`wrap.h`进行了出错封装，忘记了这回事，这说明封装系统调用时一定要小心，不能对出错处理一刀切，尤其是
出现非阻塞IO和信号之后）