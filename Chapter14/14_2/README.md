# 生产者消费者模型
## 程序功能
分别用信号量和条件变量实现了多线程下的多生产者多消费者模型，对比了两个的实现难度以及运行效率，发现在该问题中信号量的运行效率更高。

## 实现过程
在头文件`14_2.h`中封装了操作信号量、互斥量、条件变量的类，简化操作，其中条件变量的创建需要注意从外部传入互斥量，这样才能保证多个条件变量共享同一个互斥量，该互斥量用于保证对条件的操作（判断、修改）具有原子性，同时保证`pthread_cond_wait`操作（将线程放入条件变量的等待队列中）的原子性

将生产和消费的操作封装在管理资源的模板类`Pool`中，消费者线程和生产者线程通过同一个`Pool`对象进行生产和消费，并将日志信息保存在对应的文件中

两种实现方式分别放在两个命令空间中：`impl_sem`和`impl_cond`，除此之外其他的接口都完全相同，如果我们想要在两者之间进行切换只需要将`pool`的类型进行更改即可，其他地方都不需要改变

通过向`model`函数传递参数，我们可以改变产品池的大小、生产者线程的个数、消费者线程的个数。

产品池的实现是通过一个简单的循环队列，其实使用一个`queue`应该会简单一些

## 实现细节
- 创建多线程中最主要的细节是标识新线程的类型是`pthread_t`，而不像`fork`的返回值是`int`，如果这里也使用`int`的话可能会报错，刚开始一直忘记
- 使用信号量同时要辅助一个互斥量来对共享数据进行访问，要注意互斥量的临界区中不应该包含对信号量的操作，否则有可能造成死锁，互斥量是为了让对共享数据的操作变成原子操作，但是对信号量的操作本身就是原子的，不需要互斥量保护，最主要的原因还是两者的作用要求，信号量表示的是是否有对共享数据操作的权限，应该先有权限再操作
- 相比信号量的使用，条件变量的使用要更灵活一些，主要就是对条件变量所使用互斥量的使用，因为对条件的判断、修改操作本身就需要互斥量进行保护，如果不使用条件变量的互斥量就得自己定义互斥量，而自己定义的互斥量无法做到`pthread_cond_wait`的同时进行`unlock`

## 效率对比
通过让两种实现运行相同的时间，然后记录操作的次数——通过日志的行数（每进行一次操作会输出一行日志）来反应两种实现方式的的效率。
实际测试中分别无阻塞地运行1s，运行五次，记录日志的行数，取平均值反应两者的运行效率：

- 信号量实现：38928、40030、42498、39557、38818，平均39966.2
- 条件变量实现：36034、34738、36236、35523、36747，平均35855.6

我们可以发现，信号量的实现效率更高，但是条件变量更加灵活，信号量要求必须是整数，但是条件变量的条件可以灵活多变，两个各有优点
